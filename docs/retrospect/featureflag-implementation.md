# Feature Flag 구현 회고록

## 개요

본 문서는 **Prototype Reservation System**에서 Feature Flag 시스템을 구현하면서 경험했던 고민들과 결정 과정을 정리한 회고록입니다. 단순한 기능 개발을 넘어서 **아키텍처적 사고**, **성능 최적화**, **운영 안정성** 측면에서의 깊은 고민들을 담았습니다.

## 핵심 고민 주제들

### 1. 평가 로직 설계: 명확성 vs 복잡성

#### 고민의 시작
Feature Flag의 핵심은 "이 기능을 실행할 것인가?"를 결정하는 것입니다. 하지만 단순한 true/false를 넘어서 **실제 운영 환경에서의 다양한 시나리오**를 고려해야 했습니다.

#### 깊은 고민
- **점진적 기능 전환**: 기존 로직과 새로운 로직을 어떻게 안전하게 전환할 것인가?
- **Fallback 전략**: 새로운 기능이 비활성화되었을 때 어떤 동작을 할 것인가?
- **예외 처리**: 의도하지 않은 실행을 어떻게 방지할 것인가?

#### 최종 결정
```kotlin
// 3가지 명확한 시나리오
1. ff(y) → 메소드 실행
2. ff(n) + fallback 존재 → fallback 실행  
3. ff(n) + fallback 없음 → exception 발생
```

#### 교훈
복잡한 조건문보다는 **명확한 3단계 로직**이 운영 환경에서의 예측 가능성을 높였습니다. 개발자가 의도하지 않은 동작이 발생할 가능성을 원천 차단했습니다.

---

### 2. 캐싱 전략: 편의성 vs 제어권

#### 고민의 시작
Feature Flag는 **고빈도 조회**가 예상되는 데이터입니다. 하지만 Spring의 `@Cacheable`을 사용할지, 아니면 **직접 Cache-aside 패턴을 구현**할지 고민이 있었습니다.

#### 깊은 고민
- **Spring @Cacheable의 한계**: 
  - Redis 연결 실패 시 세밀한 제어 불가
  - Retry 정책을 Cache와 DB에 다르게 적용하기 어려움
  - Cache 저장 실패 처리 복잡도
  
- **직접 구현의 부담**:
  - 더 많은 코드 작성 필요
  - Cache miss/hit 로직 직접 관리
  - 동시성 이슈 고려 필요

#### 최종 결정
**Cache-aside 패턴 직접 구현**을 선택했습니다.

```kotlin
// 의사코드
fun getFeatureFlag(key: String): FeatureFlag {
    return redisRepository.get(key) 
        ?: databaseRepository.get(key)
            .also { redisRepository.setIfAbsent(it) }
}
```

#### 교훈
**편의성보다 제어권**을 선택한 결정이 옳았습니다. 특히 Redis와 DB에 서로 다른 Retry 정책을 적용할 수 있게 되어 **장애 상황에서의 복원력**이 크게 향상되었습니다.

---

### 3. Retry 정책: 복구 vs 성능

#### 고민의 시작
일시적인 네트워크 장애는 언제든 발생할 수 있습니다. 하지만 **얼마나 많이, 얼마나 자주 재시도**할 것인지는 성능과 안정성의 트레이드오프였습니다.

#### 깊은 고민
- **Redis vs DB의 다른 특성**:
  - Redis: 빠르지만 메모리 기반으로 일시적 장애 가능성
  - DB: 느리지만 안정적, 과도한 재시도 시 부하 증가
  
- **전체 응답 시간 고려**:
  - 최악의 경우: Redis 3회 실패 + DB 2회 실패 = 총 5회 호출
  - 사용자 경험에 미치는 영향

#### 최종 결정
**계층별 차등 Retry 정책**:
- Redis: 3회 retry (빠른 복구 시도)
- DB: 2회 retry (안정성 우선, 부하 방지)

#### 교훈
**인프라의 특성을 고려한 차등 정책**이 전체 시스템의 안정성을 높였습니다. 획일적인 정책보다는 각 계층의 특성에 맞는 세밀한 조정이 필요했습니다.

---

### 4. FailOver vs CircuitBreaker: 단순함 vs 고급 패턴

#### 고민의 시작
Redis 장애 시 DB로 전환하는 전략을 수립해야 했습니다. 초기에는 **Resilience4j CircuitBreaker**를 고려했지만, 과연 이것이 Feature Flag라는 경량 작업에 필요한지 깊은 고민이 있었습니다.

#### 깊은 고민
- **CircuitBreaker의 장단점**:
  - 장점: Circuit Open/Half-Open 패턴으로 정교한 제어
  - 단점: Feature Flag 조회라는 간단한 작업에는 과도한 복잡성
  
- **단순 Try-Catch의 장단점**:
  - 장점: 코드 명확성, 낮은 학습 비용
  - 단점: 고급 패턴 부재

#### 최종 결정
**Try-catch 기반 단순 failover** 선택:

```kotlin
fun getFeatureFlag(key: String): FeatureFlag {
    return try {
        redisRepository.get(key) ?: fetchFromDbAndCache(key)
    } catch (e: RedisException) {
        databaseRepository.get(key) // Simple failover
    }
}
```

#### 교훈
**Over-engineering을 피하고 문제의 본질에 집중**하는 것이 중요했습니다. Feature Flag는 경량 작업이고, Redis/MySQL은 안정적인 인프라이므로 복잡한 Circuit 패턴이 불필요했습니다.

---

### 5. Cache Stampede: 동시성 제어

#### 고민의 시작
다중 노드 환경에서 캐시 미스가 발생할 때, **모든 노드가 동시에 DB를 조회하고 Redis에 저장**하려고 시도하는 문제가 있었습니다.

#### 깊은 고민
- **분산락 vs 원자적 연산**:
  - 분산락: 정교한 제어 가능하지만 복잡성 증가
  - 원자적 연산: 단순하지만 일부 요청이 "실패"로 보일 수 있음
  
- **Feature Flag의 특성 고려**:
  - 모든 노드가 동일한 데이터를 저장
  - 저장 실패해도 실제로는 원하는 결과 달성

#### 최종 결정
**Redis SETNX(setIfAbsent) 활용**:

```kotlin
redisRepository.setIfAbsent(key, value) 
// 첫 번째 노드만 성공, 나머지는 이미 저장된 데이터 사용
```

#### 교훈
**문제의 본질을 이해하면 단순한 해결책**이 나옵니다. Feature Flag 데이터의 특성상 "누가 저장하든 같은 데이터"라는 점을 활용하여 복잡한 분산락 없이도 동시성 문제를 해결할 수 있었습니다.

---

### 6. 라이브러리 선택: 필요 vs 의존성

#### 고민의 시작
초기 설계에서는 **Resilience4j**를 포함하여 다양한 라이브러리를 고려했습니다. 하지만 실제 요구사항을 분석해보니 많은 기능이 불필요했습니다.

#### 깊은 고민
- **기능 vs 복잡성**: 더 많은 기능이 항상 더 좋은 것일까?
- **학습 비용**: 팀원들이 새로운 라이브러리를 학습하는 비용
- **의존성 관리**: 외부 라이브러리 업데이트, 보안 패치 등의 관리 부담

#### 최종 결정
**Resilience4j 제거, Spring Retry만 사용**:

```kotlin
// Before: Resilience4j CircuitBreaker
// After: Spring Retry + Simple try-catch
```

#### 교훈
**"필요한 만큼만" 원칙**이 중요했습니다. 멋진 도구가 있다고 해서 무조건 사용하는 것이 아니라, **실제 문제를 해결하는 데 꼭 필요한지** 판단하는 것이 핵심이었습니다.

---

## 전체적인 깨달음

### 1. 아키텍처는 비즈니스 요구사항에서 나온다
Feature Flag라는 간단해 보이는 기능이지만, **실제 운영 환경의 요구사항**(고가용성, 빠른 응답, 점진적 배포)을 만족시키기 위해서는 깊은 아키텍처적 고민이 필요했습니다.

### 2. 단순함이 우선이다
복잡한 패턴이나 라이브러리보다는 **문제의 본질을 이해하고 단순하게 해결**하는 것이 더 효과적이었습니다. Over-engineering을 피하고 필요한 만큼만 구현하는 것이 중요했습니다.

### 3. 인프라 특성을 이해해야 한다
Redis와 MySQL의 서로 다른 특성을 이해하고, **각각에 맞는 다른 전략**을 적용하는 것이 전체 시스템의 안정성을 높였습니다.

### 4. 동시성은 항상 고려해야 한다
단일 서버 환경에서는 문제없던 로직도 **다중 노드 환경에서는 예상치 못한 문제**가 발생할 수 있습니다. 설계 단계에서부터 동시성을 고려해야 합니다.

### 5. 트레이드오프를 명확히 하자
모든 기술적 결정에는 트레이드오프가 있습니다. **장단점을 명확히 정리하고 문서화**하여 추후 변경이 필요할 때 판단 근거로 활용할 수 있도록 했습니다.

---

## 향후 개선 방향

### 1. 모니터링 강화
- Feature Flag 사용률 지표
- Cache hit/miss 비율
- Failover 발생 빈도

### 2. 동적 설정 지원
- 서버 재시작 없이 Flag 값 변경
- 점진적 롤아웃 비율 조정

### 3. A/B 테스트 확장
- 사용자 그룹별 Feature Flag
- 비즈니스 지표와 연동

---

## 마치며

Feature Flag 구현은 단순한 기능 개발이 아닌 **시스템 아키텍처에 대한 종합적인 사고 과정**이었습니다. 각각의 결정이 서로 영향을 미치며, 전체적인 시스템의 안정성과 성능에 기여하는 것을 경험할 수 있었습니다.

가장 중요한 교훈은 **"왜 이런 결정을 내렸는가?"를 명확히 하고 문서화하는 것**입니다. 이는 추후 시스템 진화 과정에서 소중한 자산이 될 것입니다.