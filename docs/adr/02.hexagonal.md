# ADR: Hexagonal Architecture with Multi-Module & Command-Query UseCase 설계

## 맥락

프로젝트 시작 시점에서 Spring Boot 환경에서 Hexagonal Architecture를 구현할 때, 다음과 같은 핵심 결정사항들이 필요했습니다:

1. **모듈 구조**: 싱글 모듈 vs. 멀티 모듈
2. **UseCase 세분화**: 큰 단위의 UseCase vs. Command/Query 별 세분화된 UseCase
3. **Service 구조**: UseCase 여러개당 Service 하나 vs. UseCase당 Service 하나

### 고려한 설계 옵션들

#### 1. 모듈 구조 옵션
**Option A: 싱글 모듈**
- 장점: 단순한 프로젝트 구조, 빠른 초기 개발
- 단점: 계층간 의존성 위반 가능성, 패키지 수준의 격리만 가능

**Option B: 멀티 모듈**
- 장점: 물리적 계층 분리, 컴파일 타임 의존성 검증
- 단점: 복잡한 빌드 설정, 초기 구조 설계 비용

#### 2. UseCase 세분화 옵션
**Option A: 도메인별 큰 단위 UseCase**
```kotlin
interface UserUseCase {
    fun createUser(command: CreateUserCommand): Boolean
    fun findUser(query: FindUserQuery): User?
    fun updateUser(command: UpdateUserCommand): Boolean
    fun deleteUser(command: DeleteUserCommand): Boolean
}
```

**Option B: Command/Query별 세분화된 UseCase**
```kotlin
interface CreateGeneralUserUseCase {
    fun execute(command: CreateGeneralUserCommand): Boolean
}

interface FindGeneralUserUseCase {
    fun execute(query: FindGeneralUserQuery): User?
}
```

#### 3. Service 구조 옵션
**Option A: UseCase 여러개당 Service 하나**
```kotlin
@UseCase
class UserService : CreateUserUseCase, FindUserUseCase, UpdateUserUseCase
```

**Option B: UseCase당 Service 하나**
```kotlin
@UseCase  
class CreateGeneralUserService : CreateGeneralUserUseCase

@UseCase
class FindGeneralUserService : FindGeneralUserUseCase
```

### 추가 고려사항: CQRS 가능성

연습용 프로젝트로서 향후 **CQRS(Command Query Responsibility Segregation)** 패턴 적용을 고려하고 있었습니다. 이는 Command와 Query를 완전히 분리된 모델로 처리하여:
- Command: 상태 변경 담당
- Query: 데이터 조회 담당  
- 각각 다른 데이터 저장소나 최적화 전략 적용 가능

이러한 미래 확장 가능성이 Command/Query 세분화 설계에 추가적인 동기를 제공했습니다.

## 결정사항

### 1. 멀티 모듈 구조 채택

```
shared-module     (공통 유틸리티, 예외, 열거형)
├── core-module   (순수 도메인 로직)
├── application-module  (UseCase, 포트 정의)
├── adapter-module     (Controller, Repository, 외부 연동)
├── test-module       (테스트 유틸리티)
└── batch-module      (배치 작업)
```

### 2. Command/Query별 세분화된 UseCase 채택

각 비즈니스 액션당 하나의 UseCase로 설계:
- `CreateGeneralUserUseCase`
- `FindGeneralUserUseCase`  
- `ChangeGeneralUserPasswordUseCase`
- `ResignUserUseCase`

### 3. UseCase당 Service 하나 패턴 채택

```kotlin
@UseCase
class CreateGeneralUserService(
    private val createGeneralUserDomainService: CreateGeneralUserDomainService,
    private val createGeneralUser: CreateGeneralUser,
    private val checkGeneralUserDuplicated: CheckGeneralUserLoginIdDuplicated,
) : CreateGeneralUserUseCase
```

## 의사결정 근거

### 멀티 모듈을 선택한 이유

1. **컴파일 타임 의존성 검증**
   - core-module은 외부 의존성 0개로 순수 도메인 유지
   - 순환 참조 및 잘못된 의존성을 컴파일 시점에 감지

2. **명확한 계층 분리**
   - 물리적 모듈 경계로 인한 강제된 아키텍처 준수
   - 팀 개발 시 각 모듈별 담당 영역 명확화

3. **재사용성과 배포 독립성**
   - core-module과 application-module의 다른 프로젝트 재사용 가능
   - 모듈별 독립적인 테스트 및 배포 전략 수립 가능

### Command/Query별 세분화를 선택한 이유

1. **단일 책임 원칙(SRP) 준수**
   ```kotlin
   // 명확한 단일 책임
   interface CreateGeneralUserUseCase {
       fun execute(command: CreateGeneralUserCommand): Boolean
   }
   ```

2. **CQRS 패턴으로의 발전 가능성**
   - Command와 Query가 이미 개념적으로 분리되어 있어 향후 CQRS 적용 용이
   - 연습용 프로젝트로서 다양한 아키텍처 패턴 실험 기반 마련

3. **Interface Segregation Principle (ISP) 준수**
   - 클라이언트가 사용하지 않는 메서드에 의존하지 않음
   - 각 Controller는 필요한 UseCase만 주입받음

4. **테스트 용이성**
   - 각 UseCase별 독립적인 단위 테스트 작성 가능
   - Mock 객체 설정 시 불필요한 메서드 제외 가능

5. **변경 영향도 최소화**
   - 특정 기능 변경이 다른 기능에 미치는 영향 최소화
   - 새로운 기능 추가 시 기존 UseCase 영향 없음

### UseCase당 Service 하나를 선택한 이유

1. **명확한 책임 분리**
   ```kotlin
   @UseCase
   class CreateGeneralUserService : CreateGeneralUserUseCase {
       // 사용자 생성에만 집중
   }
   ```

2. **의존성 최적화**
   - 각 Service는 해당 기능에 필요한 의존성만 주입
   - 불필요한 의존성으로 인한 복잡도 제거

3. **병렬 개발 용이성**
   - 팀원별로 독립적인 Service 개발 가능
   - 기능별 개발 완료 시점이 달라도 영향 없음

## 트레이드오프

### 선택한 설계의 단점

1. **초기 복잡성**
   - 많은 수의 UseCase 및 Service 클래스
   - 프로젝트 구조 파악에 시간 필요

2. **보일러플레이트 코드**
   - 단순한 CRUD 작업도 별도 UseCase/Service 필요
   - 반복적인 패턴의 코드 작성

3. **빌드 복잡성**
   - 멀티 모듈 의존성 관리
   - 순환 참조 방지를 위한 지속적인 관리 필요

### 대안 설계 대비 장점

1. **유지보수성**: 기능별 명확한 경계와 책임
2. **테스트 용이성**: 독립적인 단위 테스트 작성 가능
3. **확장성**: 새 기능 추가 시 기존 코드 영향 최소
4. **아키텍처 준수**: 컴파일 타임 검증을 통한 설계 원칙 보장
5. **미래 확장**: CQRS 등 고급 패턴 적용 기반 마련

## 실제 결과 및 경험

### 성공적 달성 사항

1. **의존성 격리**: core-module의 외부 의존성 0개 달성
2. **테스트 커버리지**: 각 모듈별 95% 이상 테스트 커버리지 달성
3. **컴파일 타임 안전성**: 잘못된 의존성 주입 시 빌드 실패로 조기 발견
4. **명확한 책임**: UseCase별 명확한 비즈니스 의도 표현

### 예상하지 못한 도전과 해결

1. **UseCase 폭증으로 인한 관리 복잡성**
   - **문제**: 30개 이상의 UseCase로 인한 패키지 구조 복잡화
   - **해결**: 도메인별 패키지 세분화 및 명명 규칙 확립

2. **Service 간 코드 중복**
   - **문제**: 유사한 로직이 여러 Service에 중복
   - **해결**: Domain Service 계층 도입으로 공통 로직 추출

3. **의존성 주입 복잡성**
   - **문제**: 많은 수의 작은 Service들로 인한 의존성 관리 복잡화
   - **해결**: Spring의 자동 구성 활용 및 @UseCase 어노테이션으로 일관된 설정

### CQRS 준비도 검증

Command/Query 분리 설계로 인해 다음과 같은 CQRS 준비 상태를 확보:
- Command UseCase와 Query UseCase의 명확한 분리
- 각각 다른 최적화 전략 적용 가능한 구조
- 향후 별도 데이터 저장소 분리 시 최소한의 변경으로 적용 가능

## 현재 상태 검증

### 모듈 구조 효과성
```kotlin
// core-module: 순수 도메인, 외부 의존성 없음
dependencies {
    implementation(project(":shared-module"))
    // 외부 라이브러리 의존성 없음
}

// application-module: UseCase 정의, 도메인에만 의존
dependencies {
    implementation(project(":shared-module"))
    implementation(project(":core-module"))
}
```

### UseCase 세분화 효과
- 현재 32개의 UseCase로 세분화
- 각 UseCase는 단일 비즈니스 액션 담당
- 테스트 작성 및 유지보수 용이성 확인
