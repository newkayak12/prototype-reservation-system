# ADR: DDD Entity와 JPA Entity 분리 설계


## 맥락

프로젝트 시작 시점에서 Spring Boot와 JPA 환경에서 Domain-Driven Design(DDD)을 구현할 때, 도메인 엔티티와 JPA 영속성 엔티티를 어떻게 설계할지에 대한 중요한 아키텍처 결정이 필요했습니다.

고려한 두 가지 주요 접근법:

1. **통합 접근법**: JPA Entity에 도메인 로직 포함
2. **분리 접근법**: Domain Entity와 JPA Entity 완전 분리

### 당시 예상되었던 문제점들

#### JPA Entity에 도메인 로직 포함 시 우려사항
- **JPA 제약사항**: `@Entity`의 기본 생성자, getter/setter 강제로 인한 캡슐화 제약
- **캡슐화 저해**: JPA 요구사항으로 인한 불변성 보장의 어려움
- **의존성 오염**: 도메인 계층이 인프라스트럭처(JPA) 의존성을 가지게 될 위험
- **테스트 복잡성**: 도메인 로직 테스트 시 JPA 컨텍스트가 필요할 가능성
- **도메인 표현력 저하**: JPA 제약으로 인한 풍부한 도메인 모델링 한계

## 결정사항

**Domain Entity와 JPA Entity를 완전 분리하는 설계를 채택**

### 계획된 아키텍처 구조

```
core-module (Domain Layer)
├── User.kt                    // 순수 도메인 엔티티
├── Restaurant.kt              // 순수 도메인 엔티티
└── vo/                        // Value Objects

adapter-module (Infrastructure Layer)
├── UserEntity.kt              // JPA 영속성 엔티티
├── RestaurantEntity.kt        // JPA 영속성 엔티티
└── repository/                // 엔티티 변환 및 조작 로직
```

### 설계 원칙

1. **순수 도메인 모델**: `core-module`은 JPA 의존성 없는 순수 Kotlin 클래스로 구성
2. **불변성 보장**: 도메인 엔티티는 가능한 한 불변 객체로 설계
3. **캡슐화 강화**: 도메인 로직과 비즈니스 규칙의 완전한 캡슐화
4. **계층 분리**: 각 계층의 명확한 책임과 의존성 방향 준수

## 영향

### 기대되는 장점
1. **도메인 순수성**: JPA 제약 없는 풍부한 도메인 표현 가능
2. **테스트 용이성**: 도메인 로직을 JPA 컨텍스트 없이 단위 테스트 가능
3. **재사용성**: 도메인 모델을 다른 영속성 기술에서도 재사용 가능
4. **유지보수성**: 도메인 로직과 영속성 로직의 명확한 분리

### 예상되는 트레이드오프
1. **개발 복잡성**: 두 개의 엔티티 모델 유지 관리
2. **매핑 오버헤드**: 엔티티 간 변환 로직의 성능 비용
3. **학습 곡선**: 팀원들의 DDD 패턴 이해 필요

---

## 실제 결과 

### 성공적 달성 사항
- **도메인 계층 테스트 커버리지**: 95% 이상 달성
- **JPA 의존성 제거**: `core-module`의 외부 의존성 0개 달성

### 예상하지 못했던 도전과 해결
1. **복잡한 일대다 관계 조작 문제**
   - **문제**: JPA Entity의 컬렉션 조작이 예상보다 복잡
   - **해결**: Mutator 객체 패턴과 `adjustXXX()` 메서드 도입

2. **엔티티 변환 복잡성**
   - **문제**: `toEntity()` 매핑 함수의 성능 이슈와 순환 참조
   - **해결**: 직접 생성 패턴으로 매핑 로직 제거

3. **도메인 순수성 유지의 어려움**
   - **문제**: 개발 편의성으로 인한 JPA 의존성 누수 유혹
   - **해결**: 물리적 모듈 분리와 코드 리뷰 체크리스트 적용

## 대안 고려사항

당시 검토했던 다른 접근법들:

1. **JPA Entity + 도메인 로직 혼합**
   - 장점: 단순한 구조, 적은 코드량
   - 단점: 도메인 순수성 훼손, 테스트 복잡성
   - **채택 안 한 이유**: DDD 원칙 위배

2. **Mapper 기반 변환 (MapStruct 등)**
   - 장점: 명시적 변환 로직, 타입 안전성
   - 단점: 성능 오버헤드, 설정 복잡성
   - **채택 안 한 이유**: 복잡한 객체 그래프에서의 성능 우려


