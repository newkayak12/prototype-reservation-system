# ADR: Feature Flag System Architecture

---

## Decision 1: Feature Flag 평가 로직

### Context
Feature flag 조회 후 실행 여부를 결정하는 로직 필요

### Decision
**3가지 시나리오**
1. `ff(y)` → 메소드 실행
2. `ff(n) + fallback 존재` → fallback 실행
3. `ff(n) + fallback 없음` → exception 발생

### Rationale
- 명확한 동작 구분
- fallback을 통한 점진적 기능 전환 지원
- exception으로 의도하지 않은 실행 방지

---

## Decision 2: 캐싱 전략 - Cache-aside 직접 구현

### Context
Redis와 MySQL 간 캐싱 전략 필요

### Decision
**Cache-aside 패턴 직접 구현**
- Redis 조회 → miss 시 DB 조회 → Redis 저장
- Read-through 아님

### Rationale
- Spring에 Redis Read-through 자동화 없음
- 명시적 캐시 제어 필요
- Retry 정책 분리 (Redis vs DB)

### Trade-offs
**장점**
- 세밀한 제어 가능
- Retry 정책 계층별 분리

**단점**
- 직접 구현 필요
- Cache 저장 실패 처리 복잡도

### Alternatives
- `@Cacheable`: 간단하지만 세밀한 제어 불가
- Read-through: Spring에 기본 지원 없음

---

## Decision 3: Retry 정책

### Context
일시적 네트워크 장애 복구 필요

### Decision
**계층별 Retry**
- Redis: 3회 retry
- DB: 2회 retry
- 최악: 총 5회 호출

### Rationale
- 일시적 장애 흡수
- Connection pool 대기 시간 확보
- 불필요한 DB 부하 방지

### Trade-offs
**장점**
- 복구 가능한 장애 자동 처리
- DB 부하 감소

**단점**
- 최악 시 응답 지연 (5회 호출)
- Retry 정책 관리 필요

---

## Decision 4: FailOver 전략 - Try-catch

### Context
Redis 장애 시 DB로 전환 필요

### Decision
**Try-catch 기반 단순 failover**
- Redis 실패 → catch → DB 조회
- CircuitBreaker 미사용

### Rationale
- Feature flag 조회는 경량 작업
- Redis/MySQL 안정적 인프라
- CircuitBreaker는 외부 시스템 차단용, 단순 failover엔 과도함

### Trade-offs
**장점**
- 코드 명확성
- 낮은 복잡도

**단점**
- Circuit Open/Half-Open 패턴 없음

### Alternatives
- Resilience4j CircuitBreaker: Over-engineering

---

## Decision 5: Resilience4j 제거

### Context
초기 설계에서 Resilience4j CircuitBreaker 고려

### Decision
**Resilience4j 제거, Spring Retry 사용**

### Rationale
- CircuitBreaker는 인프라 호출 차단용
- 단순 failover엔 불필요
- Spring Retry로 충분

### Trade-offs
**장점**
- Over-engineering 방지
- 간결한 구조

**단점**
- 고급 패턴 부재

---

## Decision 6: Cache Stampede 방지

### Context
다중 노드 환경에서 캐시 미스 시 동시에 여러 노드가 Redis에 쓰기 요청하는 문제

### Decision
**Redis SETNX(setIfAbsent) 사용**
- 원자적 연산으로 첫 번째 노드만 캐시 저장 성공
- 나머지 노드는 실패하지만 이미 캐시된 데이터 사용

### Rationale
- Feature Flag는 모든 노드가 동일한 데이터 저장
- Lock-Free Atomic Operations로 간단한 구현
- 별도 분산락 없이도 동시성 제어

### Trade-offs
**장점**
- 구현 단순
- Redis 내장 기능 활용
- 동시 쓰기 경합 방지

**단점**
- setIfAbsent 실패 시에도 실제로는 성공 상황

---


## 기술 스택

**Core**
- Spring Boot 3.x + Kotlin
- MySQL
- Redis

**Libraries**
- Spring Retry


**제외**
- ~~Resilience4j~~
- ~~Auto-disable 메커니즘~~