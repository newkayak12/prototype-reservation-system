# ADR: 시간표 배치 작업 실행 방식 선택


## 컨텍스트
예약 시스템에서 월별 시간표(TimeTable) 데이터를 생성하는 배치 작업이 필요했습니다. 각 레스토랑의 스케줄, 휴일, 테이블 정보, 시간대를 기반으로 한 달치 예약 가능한 시간표를 미리 생성해야 했습니다.

주요 요구사항:
- 월별 시간표 일괄 생성 (restaurantId, date, startTime, endTime, tableNumber, tableSize)
- 휴일 제외 처리  
- 요일별 운영시간 반영
- 대량 데이터 처리 (한 달 × 레스토랑 수 × 테이블 수 × 시간대)

배치 작업 실행 방식으로 다음 옵션들을 고려했습니다:

### 1. Spring의 @Scheduled 어노테이션

**장점:**
- 애플리케이션 내부에서 간단하게 구현 가능
- Spring Boot와 완전 통합
- 코드 레벨에서 스케줄링 로직 관리

**단점:**
- 애플리케이션 재시작 시 스케줄 정보 유실  
- 다중 인스턴스 환경에서 중복 실행 위험
- 대용량 데이터 처리 시 메모리 이슈로 애플리케이션 전체 영향
- 배치 작업 실패 시 모니터링/알림 부족
- 배치 실행 중 웹 애플리케이션 성능 저하

### 2. Quartz Scheduler + Spring Batch

**장점:**
- Spring Batch와 연동으로 청크 단위 대용량 데이터 처리
- 클러스터링 지원으로 다중 인스턴스 환경에서 안전
- 배치 작업 상태 관리 및 persistence 지원
- 실패 시 재시작 지점 관리
- JobRepository를 통한 배치 실행 이력 관리

**단점:**
- Quartz 테이블과 Spring Batch 메타 테이블 추가 필요
- 설정 복잡도 증가
- 여전히 애플리케이션 내부 실행으로 리소스 경합

### 3. 외부 인프라 (Jenkins, Cron, Kubernetes CronJob)
```bash

**장점:**
- 웹 애플리케이션과 배치 작업의 완전한 분리
- 인프라 레벨에서 스케줄링 관리
- 강력한 모니터링 및 알림 시스템  
- 배치 전용 리소스 할당으로 성능 최적화
- 실무에서 검증된 안정적인 방식
- 배치 실패 시에도 웹 서비스에 영향 없음

**단점:**
- 추가적인 인프라 설정 필요
- 로컬 개발 환경에서 테스트 복잡도 증가
- 배치 애플리케이션 별도 패키징 필요

## 결정
**외부 인프라(Jenkins)를 통한 Spring Batch 실행**을 선택했습니다.

주요 결정 요인:
1. **실무 검증성**: 대부분의 엔터프라이즈 환경에서 표준적으로 사용되는 방식
2. **리소스 분리**: 대용량 시간표 생성 시 웹 애플리케이션에 영향 없음
3. **운영 안정성**: Jenkins를 통한 중앙화된 모니터링, 알림, 재시도 정책
4. **확장성**: 향후 다른 배치 작업 추가 시에도 동일한 패턴 적용 가능

## 구현 방식

### 1. Spring Batch 기반 TimeTable 생성 배치
```kotlin
@Configuration
class TimeTableJobConfig(
    private val jobRepository: JobRepository,
) {
    @Bean("timeTableJob")
    fun timeTableJob(timeTableStep: Step): Job {
        return JobBuilder("timeTableJob", jobRepository)
            .start(timeTableStep)
            .build()
    }
}

@Component
class TimeTableItemProcessor : ItemProcessor<ScheduleWithData, List<TimeTableEntity>> {
    
    override fun process(item: ScheduleWithData): List<TimeTableEntity>? {
        val restaurantId = item.schedule.restaurantId
        val holidays = item.holidays.map { it.date }
        val dayOfTimeMap = item.timeSpans.groupBy { it.day }
        val dateSequence = generateMonthlyDates()
        val tables = item.tables

        return dateSequence
            .filterNot { it in holidays }  // 휴일 제외
            .flatMap { date ->
                val dayOfWeek = date.dayOfWeek
                val operatingTimes = dayOfTimeMap[dayOfWeek] ?: return@flatMap emptyList()
                
                operatingTimes.flatMap { timeSpan ->
                    tables.map { table ->
                        TimeTableEntity(
                            restaurantId = restaurantId,
                            date = date,
                            day = dayOfWeek,
                            startTime = timeSpan.startTime,
                            endTime = timeSpan.endTime,
                            tableNumber = table.tableNumber,
                            tableSize = table.tableSize
                        )
                    }
                }
            }
    }
}
```

### 2. 수동 실행용 REST API 제공  
```kotlin
@RestController
class TimeTableBatchController(
    private val jobLauncher: JobLauncher,
    @Qualifier("timeTableJob") private val timeTableJob: Job
) {
    @PostMapping("/api/batch/timetable/fire")
    fun fireTimeTableBatch() {
        val jobParameter = JobParametersBuilder()
            .addLocalDate("date", YearMonth.now().atDay(1))
            .toJobParameters()
            
        jobLauncher.run(timeTableJob, jobParameter)
    }
}
```

### 3. 별도 배치 애플리케이션 모듈
```kotlin
// batch-module
@SpringBootApplication
@EnableBatchProcessing
@ImportAutoConfiguration(classes = [
    JpaAutoConfiguration::class,
    HibernateJpaAutoConfiguration::class
])
class ReservationBatchApplication

fun main(args: Array<String>) {
    runApplication<ReservationBatchApplication>(*args)
}
```

## 결과
1. **성능 분리**: 대용량 시간표 생성 시에도 웹 애플리케이션 성능에 영향 없음
2. **운영 안정성**: Jenkins를 통한 중앙화된 배치 관리 및 모니터링  
3. **확장성**: 새로운 배치 작업 추가 시 동일한 패턴으로 확장 가능
4. **장애 격리**: 배치 실패 시에도 예약 서비스는 정상 동작
5. **리소스 최적화**: 배치 실행 시에만 필요한 메모리/CPU 할당

## 향후 고려사항
- Kubernetes 환경 이전 시 CronJob으로 마이그레이션
- 배치 실행 시간 최적화 (청크 사이즈, 병렬 처리)
- 배치 실행 결과 메트릭 수집 및 대시보드 구성
- 다른 도메인 배치 작업 추가 시 공통 패턴 추출