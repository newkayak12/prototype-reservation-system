# ADR: Kafka 기반 Timetable-Reservation EDA 설계

## 맥락

예약 시스템에서 Timetable 점유 완료 시 Reservation 생성을 위한 Event-Driven Architecture가 필요합니다. Timetable이 이미 분산락/세마포어로 동시성 제어되어 예약 처리의 Source of Truth 역할을 하며, Reservation은 사용자 중심의 예약 관리 도메인입니다.

### 기본 요구사항
- Timetable 점유 완료 시 Reservation 자동 생성
- 레스토랑별 순서 보장 (같은 restaurantId)
- 높은 처리량과 확장성
- 장애 상황에서 메시지 유실 방지
- Eventually Consistent하되 신뢰성 있는 처리

### 도메인 관계
- **Timetable**: 예약 처리의 Source of Truth (분산락/세마포어 기반 동시성 제어)
- **Reservation**: 사용자 예약 관리 도메인 (취소 시 Timetable로 역산 가능)

## 고려된 설계 옵션들

### Option A: 동기 호출 방식
**장점**: 강한 일관성, 단순한 에러 처리
**단점**: 결합도 증가, 성능 저하, 확장성 제한

### Option B: Message Queue (RabbitMQ) 기반
**장점**: 전통적 방식, 안정성
**단점**: 순서 보장 복잡, 파티셔닝 제한

### Option C: Kafka 기반 Event-Driven (선택됨)
**장점**: 높은 처리량, 파티션 기반 순서 보장, 수평 확장성, 내구성
**단점**: 인프라 복잡도, Eventually Consistency

## 결정사항

**Kafka 기반 Event-Driven Architecture 채택**

### 핵심 아키텍처

#### 1. Topic & Partitioning 설계
- **Topic**: `timetable-occupancy-events`
- **Partition Key**: `restaurantId` (레스토랑별 순서 보장)
- **Partition 수**: 3개 (확장성과 순서보장 균형)

#### 2. Event Publishing 전략
- **Trigger**: Timetable `attachOccupied()` 완료 시
- **Publisher**: Timetable 도메인 서비스
- **Pattern**: Transactional Outbox Pattern

#### 3. Payload 전략

##### 고려된 Payload 옵션들:

**Option A: Full Payload**
```json
{
  "eventType": "TIMETABLE_OCCUPIED",
  "timeTableId": "uuid",
  "restaurantId": "restaurant-123", 
  "userId": "user-456",
  "occupiedAt": "2024-12-02T10:30:00",
  "tableInfo": { "tableNumber": 5, "tableSize": 4 }
}
```
- 장점: 컨슈머에서 바로 처리 가능
- 단점: 메시지 크기 증가, 스키마 진화 복잡

**Option B: Zero Payload (선택됨)**
```json
{
  "eventType": "TIMETABLE_OCCUPIED",
  "timeTableId": "uuid",
  "restaurantId": "restaurant-123"
}
```
- 장점: 메시지 경량, 스키마 안정성, DLQ 재처리 안전성
- 단점: 컨슈머에서 추가 조회 필요

**결정**: Zero Payload 방식 채택
- DLQ 재처리 시 최신 상태 조회로 안전성 확보
- 메시지 크기 최적화
- 스키마 진화 용이성

#### 4. Consumer 설계
- **Pattern**: ParallelConsumer 활용
- **목적**: 같은 파티션 내에서도 처리량 향상
- **순서**: restaurantId 기반 순서는 파티션 레벨에서 보장

#### 5. 신뢰성 보장

##### Outbox Pattern 구현
- Timetable 변경과 Event 발행을 같은 트랜잭션 내 처리
- 미처리 Outbox 엔트리는 스케줄 작업으로 재처리

**Outbox 처리 방식 결정: 스케줄러 기반 채택**

**고려된 옵션:**

**Option A: 스케줄러 기반 재처리 (채택됨)**
- Outbox 저장 → Producer 실행 → 실패 시 Status 업데이트 → 스케줄러가 주기적으로 미처리 Outbox 재처리
- 장점: 구현 단순, 기존 인프라 활용
- 단점: 지연 시간, 폴링 오버헤드

**Option B: CDC (Change Data Capture) 기반 (배제됨)**
- Outbox 저장 → CDC가 변경 감지 → 즉시 Kafka Producer 트리거
- 장점: 실시간성, 폴링 오버헤드 없음
- 단점: CDC 인프라 필요 (Debezium 등), 복잡도 증가

**스케줄러 방식 채택 이유:**
- **운영 복잡도 최소화**: CDC 도입 시 Debezium, Kafka Connect, MySQL binlog 설정 등 추가 인프라 관리 필요
- **장애 격리**: 스케줄러 실패는 애플리케이션 레벨에서 처리 가능하지만, CDC 장애는 인프라 레벨 대응 필요
- **점진적 확장**: 초기에는 단순 구조로 시작하여 트래픽 증가 시 CDC로 전환 계획
- **디버깅 편의성**: 스케줄러 기반 재처리는 로그 추적과 수동 재처리 용이

**실무 고려사항**: 대규모 시스템에서는 CDC 방식이 성능상 유리하나, 본 프로젝트에서는 단순함을 우선시

##### 실패 처리 전략

**Producer 실패 처리: Outbox Pattern**
- Timetable 변경과 Event 발행을 동일 트랜잭션으로 처리
- 미처리 Outbox 엔트리는 스케줄러로 재처리
- At-least-once 메시지 발행 보장

**Consumer 실패 처리: 강제 커밋 + PoisonMessage**
- 재시도 후 최종 실패 시 강제 커밋 처리
- PoisonMessage 별도 저장 및 모니터링
- DLQ 사용하지 않고 애플리케이션 레벨에서 처리
- 장점:
  - 오프셋 진행으로 Consumer 블로킹 방지
  - PoisonMessage 별도 관리로 운영 편의성
  - Zero Payload 특성으로 재처리 시 최신 상태 검증 가능

**PoisonMessage 운영 관리**
- **저장 위치**: 별도 운영 전용 DB
- **처리 방식**: 개발자 수동 처리
- **알림**: PoisonMessage 발생 시 즉시 슬랙 알림
- **상태 관리**: PENDING/RESOLVED/IGNORED 상태 추적
- **재처리**: Zero Payload로 최신 Timetable 상태 재검증 후 수동 처리

## 장점

1. **순서 보장**: restaurantId 파티션 키로 레스토랑별 순서 보장
2. **확장성**: Kafka 파티션 기반 수평 확장
3. **성능**: ParallelConsumer로 처리량 향상
4. **안전성**: Outbox 패턴으로 메시지 유실 방지
5. **유연성**: Zero Payload로 DLQ 재처리 안전성

## 트레이드오프

### 선택한 방식의 한계
- Eventually Consistency (즉시 일관성 불가)
- Kafka 인프라 의존성
- 복잡한 에러 처리 및 모니터링 필요

### 포기한 대안들
- **동기 호출**: 성능과 확장성 제한
- **Strong Consistency**: 분산 환경에서 성능 저하
- **Full Payload**: 메시지 크기와 스키마 진화 복잡성

## 미결정 사항 및 추가 논의

### 1. 보상 트랜잭션 전략
- **보상 트랜잭션**: Reservation 생성 불가 시 Timetable 상태 보정 여부
- **필터링 로직**: Zero Payload 재조회 시 Timetable 상태 검증 기준

### 2. 성능 최적화
- ParallelConsumer 설정 최적화
- 배치 크기 및 처리 간격 조정

## 결과

이 설계로 다음을 달성:
- Timetable과 Reservation 간 느슨한 결합
- 높은 처리량과 확장성
- 레스토랑별 순서 보장
- 장애 상황에서 신뢰성 있는 메시지 처리
- Zero Payload 기반 안전한 재처리